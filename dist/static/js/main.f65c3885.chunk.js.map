{"version":3,"sources":["components/layout/GeoLocation.js","components/layout/GeoWrapper.js","App.js","serviceWorker.js","index.js"],"names":["GeoLocation","state","data","name","lat","lon","getDistance","coord1","coord2","p","c","Math","cos","lat1","latitude","lon1","longitude","lat2","lon2","a","asin","sqrt","componentDidUpdate","prevs","_this","coords","props","setCoords","forEach","item","dist","console","log","componentDidMount","_this$props","this","isGeolocationAvailable","isGeolocationEnabled","cnt","react_default","createElement","Fragment","positionError","Component","geolocated","positionOptions","enableHighAccuracy","userDecisionTimeout","GeoWrapper","timer","key","Date","getTime","handleSetCoords","setState","window","setInterval","checkCoords","clearInterval","location","reload","layout_GeoLocation","App","className","layout_GeoWrapper","Boolean","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.f65c3885.chunk.js","sourcesContent":["import React, { Component } from 'react'\r\nimport { geolocated } from 'react-geolocated'\r\n\r\nclass GeoLocation extends Component {\r\n    state = {\r\n        data: [\r\n            { name: '성신여대 CGV', lat: 37.592526, lon: 127.016974 },\r\n            { name: '피자헛', lat: 37.592134, lon: 127.017755 },\r\n            { name: '한성대입구역', lat: 37.588491, lon: 127.006194 },\r\n            { name: '부산', lat: 35.145806, lon: 129.028514 },\r\n            { name: '노트북', lat: 37.592483099999995, lon: 127.0078127 }\r\n        ],\r\n    }\r\n    getDistance = (coord1, coord2) => {\r\n        var p = 0.017453292519943295;    // Math.PI / 180\r\n        var c = Math.cos;\r\n        var lat1 = coord1.latitude;\r\n        var lon1 = coord1.longitude;\r\n        var lat2 = coord2.latitude;\r\n        var lon2 = coord2.longitude;\r\n\r\n        var a = 0.5 - c((lat2 - lat1) * p) / 2 +\r\n            c(lat1 * p) * c(lat2 * p) *\r\n            (1 - c((lon2 - lon1) * p)) / 2;\r\n\r\n        var distance = 12742 * Math.asin(Math.sqrt(a));\r\n        return distance;\r\n\r\n    }\r\n    componentDidUpdate = prevs => {\r\n        const { data } = this.state;\r\n        const { coords } = this.props;\r\n        \r\n        if (prevs.coords !== coords && coords) {\r\n            this.props.setCoords(coords);\r\n            data.forEach(item => {\r\n                var dist = this.getDistance({ longitude: 127.0152708, latitude: 37.5917756 }, { latitude: item.lat, longitude: item.lon });\r\n                console.log(item.name + \": \" + dist * 1000 + 'm');\r\n            });\r\n        }\r\n    }\r\n    componentDidMount = () => {\r\n        console.log(this.props);\r\n    }\r\n\r\n    render() {\r\n        const { isGeolocationAvailable, isGeolocationEnabled, coords, cnt } = this.props;\r\n        return (\r\n            <div>\r\n                {!isGeolocationAvailable ? (\r\n                    <p>위치정보를 지원하지 않는 브라우저입니다.</p>\r\n                ) : (\r\n                        !isGeolocationEnabled ? (\r\n                            <p>권한없음</p>\r\n                        ) : (\r\n                                coords ? (\r\n                                    <React.Fragment>\r\n                                        <p>Latitude: {coords.latitude}</p>\r\n                                        <p>Longitude: {coords.longitude}</p>\r\n                                    </React.Fragment>\r\n                                ) : (\r\n                                        <React.Fragment>\r\n                                            <div>\r\n                                                위치 정보를 켜주세요. + {cnt}\r\n                                                {isGeolocationAvailable ? (\"권한잇음\") : \"권한없음\"}\r\n                                            </div>\r\n                                            {this.props.positionError && <p>{this.props.positionError}</p>}\r\n                                        </React.Fragment>\r\n\r\n                                    )\r\n\r\n                            )\r\n                    )}\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default geolocated({\r\n    positionOptions: {\r\n        enableHighAccuracy: false,\r\n    },\r\n    userDecisionTimeout: 5000\r\n})(GeoLocation)","import React, { Component } from 'react'\r\nimport GeoLocation from './GeoLocation'\r\n\r\nclass GeoWrapper extends Component {\r\n    state = {\r\n        timer: null,\r\n        coords: null,\r\n        key: new Date().getTime(),\r\n        cnt: 0, \r\n    }\r\n\r\n    handleSetCoords = (coords) => {\r\n        this.setState({ coords })\r\n    }\r\n    componentDidMount = () => {\r\n        this.setState({\r\n            timer: window.setInterval(this.checkCoords, 2000),\r\n        })\r\n    }\r\n    checkCoords = () => {\r\n        const { coords } = this.state;\r\n        \r\n        if (coords) {\r\n            window.clearInterval(this.state.timer);\r\n        }\r\n        else {\r\n            window.location.reload();\r\n            this.setState({\r\n                key: new Date().getTime(),\r\n                cnt: this.state.cnt + 1,\r\n            })\r\n        }\r\n    }\r\n    render() {\r\n        console.log(this.state);\r\n        return (\r\n            <div>\r\n                <GeoLocation setCoords={this.handleSetCoords} key={this.state.key} cnt={this.state.cnt} />\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default GeoWrapper","import './App.css'\nimport React, { Component } from 'react'\nimport { BrowserRouter, Switch, Route } from 'react-router-dom'\nimport GeoWrapper from './components/layout/GeoWrapper'\n\nclass App extends Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <GeoWrapper />\n      </div>\n    )\n  }\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}